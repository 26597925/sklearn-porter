var {class_name} = function(data) {{

    this.forest = data;
    this.n_estimators = this.forest.length;
    this.n_classes = this.forest['classes'][0].length;

    var findMax = function(nums) {{
        var index = 0;
        for (var i = 0; i < nums.length; i++) {{
            index = nums[i] > nums[index] ? i : index;
        }}
        return index;
    }};

    var predict = function(tree, features, node) {{
        // node = (typeof node !== 'undefined') ? node : 0;
        if (tree['thresholds'][node] != -2) {{
            if (features[tree['indices'][node]] <= tree['thresholds'][node]) {{
                return predict(tree, features, tree['lChilds'][node]);
            }} else {{
                return predict(tree, features, tree['rChilds'][node]);
            }}
        }}
        return tree['classes'][node];
    }};

    this.{method_name} = function(features) {{
        var n_estimators = this.n_estimators;
        var preds = new Array(n_estimators);
        var n_classes = this.n_classes;
        var classes = new Array(n_classes).fill(0.);
        var normalizer, sum, idx, val;
        var i, j;

        for (i = 0; i < n_estimators; i++) {{
            preds[i] = predict(this.forest[i], features, 0);
        }}
        for (i = 0; i < n_estimators; i++) {{
            normalizer = 0.;
            for (j = 0; j < n_classes; j++) {{
                normalizer += preds[i][j];
            }}
            if (normalizer == 0.) {{
                normalizer = 1.0;
            }}
            for (j = 0; j < n_classes; j++) {{
                preds[i][j] = preds[i][j] / normalizer;
                if (preds[i][j] <= 2.2204460492503131e-16) {{
                    preds[i][j] = 2.2204460492503131e-16;
                }}
                preds[i][j] = Math.log(preds[i][j]);
            }}
            sum = 0.0;
            for (j = 0; j < n_classes; j++) {{
                sum += preds[i][j];
            }}
            for (j = 0; j < n_classes; j++) {{
                preds[i][j] = (n_classes - 1) * (preds[i][j] - (1. / n_classes) * sum);
            }}
        }}
        for (i = 0; i < n_estimators; i++) {{
            for (j = 0; j < n_classes; j++) {{
                classes[j] += preds[i][j];
            }}
        }}

        return findMax(classes);
    }};

}};

if (typeof process !== 'undefined' && typeof process.argv !== 'undefined') {{
    if (process.argv.length - 2 === {n_features}) {{

        // Features:
        var features = process.argv.slice(2);

        // Parameters:
        {forest}

        // Prediction:
        var clf = new {class_name}(forest);
        var prediction = clf.{method_name}(features);
        console.log(prediction);

    }}
}}